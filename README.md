# C_Exam 2018

## Description
This is a project for decrypting encrypted password by reversing the deprecated MD5-encryption method.
This program scans a dictionary file for a correct guess, if the given hash does´n exist in the file the code will start
to "bruteforce guess" every combination up to at given password length.

### Flow of the program
1. The given hash is validated in some simple checks.
2. The given hash is splitted into two parts and saved in a struct called SplittedPassword.
3. Searches all lines in the dictionary file.
    1. Every line gets encrypted with the salt of the given hash.
    2. If there is a match the result is displayed to the user and the program is terminated.
4. Bruteforce beginning to guess password.
    1. Every guess gets encrypted with the salt of the given hash.
    2. If there is a match the result is displayed to the user and the program is terminated.

## How to run
1. Clone this repo
2. From root folder in the project, run the following commands:
    - `make`
    - `./bin/dictionary '<hash>'` 
        - Examples:
        - dictionary guess)     `./bin/main '$1$7tBjugEa$h3cZLWYTXCwqikbFvQe7A/'`
        - brute force guess)    `./bin/main '$1$JpWPMkg+$WpRBP/wtLDqu83m.wo16D0'`

### Aditional make commands
- `make clean`
  - cleans up autogenerated files
- `make remake`
  - cleans up autogenerated files and builds the program

## Missing features an known bugs
When I started on this project I implemented the feature that it would be possible to scan through a file of hashes and
return all the decrypted results, the function is still in the code but commented out and made not reachable because
in "bruteforce mode" the program exites completely without closing the file if there is a result.

I made this desition to completely exit by using `exit(0)` the program if the password needed to be bruteforced and 
disable this function because lack of time and because it wasn´t a formal requirement in the exam to have this feature implemented.

There is also a small memory leak of 601 __still reachable__ bytes from the main function, i couldn`t figure out why this happend so
I didn´t correct it. I know this isn´t perfect but still reachable memory leaks is no threat for the OS that cleans up these types of leak.
If this had been a small embedded device it had been worse.

## Additional documents
- [Exam 2018 Task](docs/ExamTask.pdf)
- [Folder structure](docs/folderStructure.md)
- [Future ideas and features](docs/futureIdeas.md)
